# Introduction #

The current support for Java i18n is not as good nor as simple as needed. To give some more usable default formatting support the Formatters has been created and to make these formatters easy to manage (change Locale for) the LocaleProfile was added.

Project is synced to Maven Central (no third party repository is needed)
```
<dependency>
    <groupId>org.hrodberaht</groupId>
    <artifactId>i18n</artifactId>
    <version>1.2.0</version>
</dependency>
```

# Details #

Formatters are "string to object" and "object to string" converters. We call this formatting and parsing.

There are formatters for anything that a normal developers needs to transform and they internally use the real java Formatters, but in a more useable and easy to handle way.
  * They always use the ParsePosition in the correct way, will never partially convert an object.
  * They will fix a JVM bug (Sun might call it feature but I disagree) with hard or normal space characters in Formatting of large numbers.
  * They will always use the LocaleProvider to find out what locale to use, this means someone using them can setup their software's Locale in one place and all formatters will follow this.

**The profile provider**
This supports instant creation profile and a thread stored profile by default. The profile provider is static (this will be upgraded to instance support in the near future to be able to have different provider in one JVM)
Usage example
```
// This mimics what can be done in a software using the profile provider.
Locale testProviderLocale = new Locale("en","US");
LocaleProvider.setThreadLocaleProvider();

// This mimics what can be done in a RequestFilter for example
LocaleProvider.setProfile(new LocaleProfile(testProviderLocale));

// All calls to the provider from now on in the current thread will return this locale
LocaleProvider.getProfile().getLocale()
```

**Formatters**
There are many Formatters, these are the currently created and supported ones with usage examples. The formatters use the LocaleProvider.getProfile().getLocale() to determine what locale to use for transformation.

### Boolean Formatter ###

```
String testBoolean = "true";
Formatter<Boolean> formatter = Formatter.getFormatter(Boolean.class);
Boolean aBoolean = formatter.convertToObject(testBoolean);
String aStringBoolean = formatter.convertToString(aBoolean);
```

### Currency Formatter ###

```
System.setProperty("localeprovide.locale", "en_US");
String testDouble = "$11,123,314";
Formatter<CurrencyData> formatter = Formatter.getFormatter(CurrencyData.class);
CurrencyData aDouble = formatter.convertToObject(testDouble);

// Some other similar code
System.setProperty("localeprovide.locale", "sv_SE");
String testDouble = "12 314";
Formatter<CurrencyData> formatter = Formatter.getFormatter(CurrencyData.class);
CurrencyData aDouble = formatter.convertToObject(testDouble);
String aStringDouble = formatter.convertToString(aDouble);
// The converter has added the locale currency symbol correctly.
assertEquals(testDouble + ",00 kr", aStringDouble);
```

### Date/Datetime Formatter ###

```
System.setProperty("localeprovide.locale", "sv_SE");
String testDate = "2010-01-01";
Formatter<Date> formatter = Formatter.getFormatter(Date.class);
Date aDate = formatter.convertToObject(testDate);
String aStringDate = formatter.convertToString(aDate);
```

With time this needs to be different, for convert to object the same formatter can be used and it will find that its a date time format automatically, but for object to string we need to help the formatter.
```
System.setProperty("localeprovide.locale", "sv_SE");
String testDate = "2010-01-01 00:00";
Formatter<Date> formatter = Formatter.getFormatter(Date.class);
Date aDate = formatter.convertToObject(testDate);

Formatter<Date> formatter = Formatter.getFormatter(Date.class, DateFormatter.DateConvert.DateTime);
String aDate = formatter.convertToString(aDate);
```

### Decimal Formatter ###

```
Formatter<Double> formatter = Formatter.getFormatter(Double.class);
Double aDouble = formatter.convertToObject(testDouble);
String aStringDouble = formatter.convertToString(aDouble);
```

### Integer Formatter ###

```
Formatter<Integer> formatter = Formatter.getFormatter(Integer.class);
Integer aInteger = formatter.convertToObject(testInteger);
String aStringInteger = formatter.convertToString(aInteger);
```

### Long Formatter ###

```
Formatter<Long> formatter = Formatter.getFormatter(Long.class);
Long aLong = formatter.convertToObject(testLong);
String aStringLong = formatter.convertToString(aLong);
```

### Percentage Formatter ###
The percent sign is added automatically
```
String testDouble = "12 314";
Formatter<PercentData> formatter = Formatter.getFormatter(PercentData.class);
PercentData aDouble = formatter.convertToObject(testDouble);
String aStringDouble = formatter.convertToString(aDouble);
assertEquals(testDouble + "%", aStringDouble);
```